<?xml version="1.0" encoding="UTF-8"?>

<!-- 
	mapper 파일은 특정 테이블에 대한 SQL 구문을 보관하는 파일이다
	- myBatis를 이용하는 개발자는 이곳에 저장된 SQL 구문을 "아이디"를 이용해서 호출한다
	- 파일마다 동일한 아이디로 인해 발생하는 충돌을 방지하기 위해 고유한 namespace를 사용한다
	- 만약 namespace가 olympic이고 구문 ID가 list라면 외부에서는 olympic.list로 호출한다
	- 일반적으로 namespace는 테이블명으로 한다! 
	- mapper 내부에는 다음 종류 태그로 구문을 저장할 수 있다.
		- insert
		- delete
		- update
		- select
 -->
<!DOCTYPE mapper
 PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
 "http://mybatis.org/dtd/mybatis-3-mapper.dtd"> 
	<mapper namespace="payment">
	
		<select id = "sequence" resultType="int">
			select payment_seq.nextval from dual
		</select>
		
		<insert id ="insert" parameterType="PaymentDto">
			insert into payment(
				payment_no,payment_tid,payment_total,payment_name,payment_time,
				payment_status
			)
			values(#{paymentNo},#{paymentTid},#{paymentTotal},#{paymentName},sysdate,'승인'
			)
		</insert>
	
		<select id = "list" resultType="PaymentDto">
			select * from payment order by payment_no desc
		</select>
	
		<select id = "one" resultType="PaymentDto" parameterType="int">
			select * from payment where payment_no = #{paymentNo}
		</select>
		
		<update id="refresh" parameterType="int">
			update payment set payment_status = (
    select 
    case
        when "all" = "success" then '승인'
        when "all" = "cancel" then '취소'
        else '부분취소'
    end
from(
    select
        (select count(*)  from payment_detail where payment_no = ${paymentNo}) "all",
        (select count(*) from payment_detail where payment_detail_status = '승인' and payment_no = ${paymentNo}) "success",
        (select count(*) from payment_detail where payment_detail_status = '취소'and payment_no = ${paymentNo}) "cancel"
    from dual

)

)where payment_no = ${paymentNo}
			
		</update>
		
		<update id = "cancelAll" parameterType="int">
			update payment set payment_status ='취소' where payment_no = #{paymentNo}
		</update>
		
		<!-- 
			ResultMap과 계층형 쿼리 조회
			- ResultMap은 임의로 컬럼을 지정할 수 있도록 만들어진 수동 매핑 도구
			- 자동으로 매핑이 불가능할 경우(ResultType)에 사용
			- 여러 가지 매핑을 위한 도구를 지원하므로 해당하는 형태에 맞게 사용
			- join, 계층형 조회 등에 유용하게 사용할 수 있다
			
			- type : 만들 매핑을 위한 클래스의 자료형
		 	- id : select구문에서 resultMap 사용할 별칭
		 -->
		 <resultMap type = "PaymentListVO" id="paymentMap">
		 		<!-- 객체 : PaymentDto 에 대한 매핑 설정 -->
		 		<association property="paymentDto" javaType="PaymentDto">
		 			<result column ="payment_no" property="paymentNo"/>
		 			<result column ="payment_tid" property="paymentTid"/>
		 			<result column ="payment_total" property="paymentTotal"/>
		 			<result column ="payment_name" property="paymentName"/>
		 			<result column ="payment_time" property="paymentTime"/>
		 			<result column ="payment_status" property="paymentStatus"/>
		 		</association>
				<!-- 컬렉션(List<PaymentDetailDto>에 대한 매핑 설정 -->
				<collection property="paymentDetailList" javaType="list" ofType = "PaymentDetailDto"
						select = "treeSearchSubquery" column = "payment_no">
					<result column="payment_detail_no" property="paymentDetailNo"/>
					<result column="payment_no" property="paymentNo"/>
					<result column="payment_detail_name" property="paymentDetailName"/>
					<result column="payment_detail_quantity" property="paymentDetailQuantity"/>
					<result column="payment_detail_price" property="paymentDetailPrice"/>
					<result column="payment_detail_status" property="paymentDetailStatus"/>
				</collection>
		 </resultMap>
		 		
		 		<select id = "treeSearch" resultMap = "paymentMap">
		 			select * from payment order by payment_no desc
		 		</select>
		 		<select id = "treeSearchSubquery" resultType = "PaymentDetailDto" parameterType = "int">
		 			select * from payment_detail
		 			where payment_no = #{paymentNo}
		 			order by payment_detail_no asc
		 		</select>
						 
		 
	</mapper> 	